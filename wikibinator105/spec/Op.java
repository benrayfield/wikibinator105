/** Ben F Rayfield offers this software opensource MIT license */
package wikibinator105.spec;


/** Generated in Op.atOpbyte(byte), and if change any of these enums, just run that again and copy it here,
and of course that would be a different function than wikibinator105...
<br><br>
op00000000: _deeplazy
op00000001: _root
op00000010: _chooser
op00000100: _chooser
op00000101: _chooser
op00001000: _chooser
op00001001: _chooser
op00001010: _chooser
op00010000: _chooser
op00010001: _chooser
op00010100: _chooser
op00100000: _chooser
op00100001: _chooser
op00101000: _chooser
op00000011: _Chooser
op00000110: _Chooser
op00000111: _Chooser
op00001100: _Chooser
op00001101: _Chooser
op00001110: _Chooser
op00011000: _Chooser
op00011001: _Chooser
op00011100: _Chooser
op00110000: _Chooser
op00110001: _Chooser
op00111000: _Chooser
op01000000: wiki
op10000000: wiki
op10000001: wiki
op01100000: Wiki
op11000000: Wiki
op11000001: Wiki
op01000001: isLeaf
op10000010: isLeaf
op10000011: isLeaf
op01100001: IsLeaf
op11000010: IsLeaf
op11000011: IsLeaf
op01000010: getFunc
op10000100: getFunc
op10000101: getFunc
op01100010: GetFunc
op11000100: GetFunc
op11000101: GetFunc
op01000011: getParam
op10000110: getParam
op10000111: getParam
op01100011: GetParam
op11000110: GetParam
op11000111: GetParam
op00100010: tru
op01000100: tru
op01000101: tru
op10001000: tru
op10001001: tru
op10001010: tru
op10001011: tru
op00110010: Tru
op01100100: Tru
op01100101: Tru
op11001000: Tru
op11001001: Tru
op11001010: Tru
op11001011: Tru
op00100011: fal
op01000110: fal
op01000111: fal
op10001100: fal
op10001101: fal
op10001110: fal
op10001111: fal
op00110011: Fal
op01100110: Fal
op01100111: Fal
op11001100: Fal
op11001101: Fal
op11001110: Fal
op11001111: Fal
op00010010: pair
op00100100: pair
op00100101: pair
op01001000: pair
op01001001: pair
op01001010: pair
op01001011: pair
op10010000: pair
op10010001: pair
op10010010: pair
op10010011: pair
op10010100: pair
op10010101: pair
op10010110: pair
op10010111: pair
op00011010: Pair
op00110100: Pair
op00110101: Pair
op01101000: Pair
op01101001: Pair
op01101010: Pair
op01101011: Pair
op11010000: Pair
op11010001: Pair
op11010010: Pair
op11010011: Pair
op11010100: Pair
op11010101: Pair
op11010110: Pair
op11010111: Pair
op00010011: trecurse
op00100110: trecurse
op00100111: trecurse
op01001100: trecurse
op01001101: trecurse
op01001110: trecurse
op01001111: trecurse
op10011000: trecurse
op10011001: trecurse
op10011010: trecurse
op10011011: trecurse
op10011100: trecurse
op10011101: trecurse
op10011110: trecurse
op10011111: trecurse
op00011011: Trecurse
op00110110: Trecurse
op00110111: Trecurse
op01101100: Trecurse
op01101101: Trecurse
op01101110: Trecurse
op01101111: Trecurse
op11011000: Trecurse
op11011001: Trecurse
op11011010: Trecurse
op11011011: Trecurse
op11011100: Trecurse
op11011101: Trecurse
op11011110: Trecurse
op11011111: Trecurse
op01010000: bit
op10100000: bit
op10100001: bit
op01110000: Bit
op11100000: Bit
op11100001: Bit
op01010001: isclean
op10100010: isclean
op10100011: isclean
op01110001: Isclean
op11100010: Isclean
op11100011: Isclean
op00101001: curryOrInfcurOrTypeval
op01010010: curryOrInfcurOrTypeval
op01010011: curryOrInfcurOrTypeval
op10100100: curryOrInfcurOrTypeval
op10100101: curryOrInfcurOrTypeval
op10100110: curryOrInfcurOrTypeval
op10100111: curryOrInfcurOrTypeval
op00111001: CurryOrInfcurOrTypeval
op01110010: CurryOrInfcurOrTypeval
op01110011: CurryOrInfcurOrTypeval
op11100100: CurryOrInfcurOrTypeval
op11100101: CurryOrInfcurOrTypeval
op11100110: CurryOrInfcurOrTypeval
op11100111: CurryOrInfcurOrTypeval
op00010101: ax
op00101010: ax
op00101011: ax
op01010100: ax
op01010101: ax
op01010110: ax
op01010111: ax
op10101000: ax
op10101001: ax
op10101010: ax
op10101011: ax
op10101100: ax
op10101101: ax
op10101110: ax
op10101111: ax
op00011101: Ax
op00111010: Ax
op00111011: Ax
op01110100: Ax
op01110101: Ax
op01110110: Ax
op01110111: Ax
op11101000: Ax
op11101001: Ax
op11101010: Ax
op11101011: Ax
op11101100: Ax
op11101101: Ax
op11101110: Ax
op11101111: Ax
op00001011: fpr
op00010110: fpr
op00010111: fpr
op00101100: fpr
op00101101: fpr
op00101110: fpr
op00101111: fpr
op01011000: fpr
op01011001: fpr
op01011010: fpr
op01011011: fpr
op01011100: fpr
op01011101: fpr
op01011110: fpr
op01011111: fpr
op10110000: fpr
op10110001: fpr
op10110010: fpr
op10110011: fpr
op10110100: fpr
op10110101: fpr
op10110110: fpr
op10110111: fpr
op10111000: fpr
op10111001: fpr
op10111010: fpr
op10111011: fpr
op10111100: fpr
op10111101: fpr
op10111110: fpr
op10111111: fpr
op00001111: Fpr
op00011110: Fpr
op00011111: Fpr
op00111100: Fpr
op00111101: Fpr
op00111110: Fpr
op00111111: Fpr
op01111000: Fpr
op01111001: Fpr
op01111010: Fpr
op01111011: Fpr
op01111100: Fpr
op01111101: Fpr
op01111110: Fpr
op01111111: Fpr
op11110000: Fpr
op11110001: Fpr
op11110010: Fpr
op11110011: Fpr
op11110100: Fpr
op11110101: Fpr
op11110110: Fpr
op11110111: Fpr
op11111000: Fpr
op11111001: Fpr
op11111010: Fpr
op11111011: Fpr
op11111100: Fpr
op11111101: Fpr
op11111110: Fpr
op11111111: Fpr
*/
public enum Op{
	
	/** opByte0. The other 255 opBytes are for each of the first 7 params being λ vs anything_except_λ,
	then pad a high 1 bit after however many params it is 0..7 if its at most 7 params,
	and if its more than 7 params it copies opByte from its l().
	When or if an opByte0 finishes evaling, it becomes 1 of those 255 opBytes.
	opByte is part of the long (64 bits) header, which is part of id256 and that long is used in memory
	even before id256 is created.
	<br><br>
	(TODO maybe used or not used? probably not in wikibinator105, but TODO think about it)
	not used in the wikibinator105 prototype since everything is either halted or evaling on java stack,
	but other implementations might use this for call pairs that are not halted.
	TODO copy comments from wikibinator104 and maybe modify them...
	<br><br>
	Anything thats not halted is deepLazy,
	other than if its l() and r() are halted but it is not cuz r() is its
	7th param (FIXME its vararg, though !isStrange ops all take 7 params, other than deepLazy
	which isnt really an op or unsure how to categorize it),
	that uses the same op as r()'s op.
	This is a low level of lazy that does not exist in the wikibinator104 prototype
	but may in other implementations of wikibinator105.
	<br><br>
	Wikibinator105 is (TODO after work out details) a specific pure math function not a specific system.
	<br><br>
	Wikibinator105 can (in theory) be mounted into (axiomforestLeaf "wikibinator105"),
	using axiomforest's kind of strings for that,
	where wikibinator104Leaf is (axiomforestLeaf "wikibinator104") and wikibinator104
	cant see anything outside of (axiomforestLeaf "wikibinator104"),
	and calling it on anything outside that is axiomforest.TruthValue.no,
	so for it to see other systems it would have to emulate axiomforest such as using
	(pair cbt16_axiomforestHeader (pair axiomforestLeftChild axiomforestRightChild)) for example.
	*/
	_deeplazy(false,false,true,false,0),
	
	/** This is like _chooser and _Chooser except its the first one (has 0 curries so far),
	and its next param chooses cleanLeaf vs dirtyLeaf.
	This node never occurs in wikibinator105 except maybe to mount it into other systems like axiomforest
	or used in optimizations.
	*/
	_root(false,false,false,true,0),
	
	/** UPDATE FIXME: The one with 0 params doesnt exist, since its just there to branch cleanLeaf vs dirtyLeaf,
	so its actually 0..6 params (or say it as 1..7),
	and the reflect ops (l r isleaf isclean, which theres 2 forms of each as clean/dirty)
	never return the one with 0 params.
	That root node may still be a useful place to mount the system into other systems such as axiomforest,
	but as far as wikibinator105 can see, theres 2 universal functions: cleanLeaf and dirtyLeaf,
	and cleanLeaf can create only clean things (even if it sees a dirty thing it gets truncated to clean first),
	and dirty is a layer above clean and can create clean and dirty things.
	They are mostly mirrors of eachother except dirty can use the wiki and in clean every call of wiki is nonhalting. 
	cleanLeaf is actually universal. You dont have to use dirtyLeaf, and can still create all possible lambdas,
	but the dirty layer is an optimization to avoid having to observe every part of Wiki function before calling it,
	which is useful since Wiki is potentially an infinite size function that accumulates
	(AxA (Fpr Wiki param returnValue)) vs (AxB (Fpr Wiki param returnValue)) as a bloomFilter
	of you can have AxA (Ax leaf x) or AxB (Ax (leaf leaf) x) but not both, for each x.
	<br><br>
	All nontrivial logic happens in params 0..7, which is described by opbyte,
	as there are 255 combos of each of those 0..7 params being leaf vs anything_except_leaf,
	and opbyte 0 is deeplazy. The position of the high 1 bit chooses a bitstring of 0..7 bits.
	Each (int)Op.curriesElse0 is 1..4 and goes at the end of that 0..7.
	Of the 128 negative opbytes (or as unsigned, the high 128),
	each op whose curriesElse0!=0 gets 1<<curriesElse0 of those 128 opbytes,
	in the order they occur in Op enum (FIXME that would require all the clean ops to come after all the dirty ops,
	or all before, instead of them occurring right next to eachother).
	After that, loop over the 64 indexs under those 128, then the 32, then 16, 8, 4, 2, 1,
	(descending order of uint8 from 127 to 1),
	and for index x, if Op.atOpbyte(x*2)==Op.atOpbyte(x*2+1) then copy Op.atOpbyte(x*2) to Op.atOpbyte(x),
	else put Op.chooser at Op.atOpbyte(x).
	Put Op.deepLazy_isNotCleanOrDirtyCuzIsNotHalted at Op.atOpbyte(0).
	That completes the mapping of byte->Op.
	<br><br>
	If a node x has more than 7 params and is halted, x.opbyte==x.l.opbyte.
	<br><br>
	If a node y has more than 7 params and is not halted (yet?),
	or if y.l.opbyte==0 or y.r.opbyte==0, then y.opbyte==0 aka Op.deepLazy,
	and no lambda can see it until it halts,
	which is a problem I plan to solve inside the sandbox by using the VM
	instead of redesigning the VM, by deriving debugStepOver and debugStepInto lambdas
	and a few related lambdas, which use the pattern-calculus ability (l r isleaf isclean)
	to basically emulate small parts of universal function so they always halt
	after doing a bigO(1) amount of work, and when called in a loop are turingComplete,
	and can push and pop emulator levels using various combos of such derived lambdas.
	<br><br>
	The node whose opbyte is 1 (aka leaf/u/theUniversalFunction),
	its left child is (fal leaf) aka identityFunc, and its right child is leaf/itself.
	That completes the opbyte for all possible sequences of l and r and all callpairs of them.
	*/
	_chooser(true,false,false,true,0),
	_Chooser(false,true,false,true,0),

	
	/** all nondeterminism goes here. TODO copy comments from wikibinator104 and maybe modify them...
	<br><br>
	if strict/clean this is (S I I (S I I)), else/dirty is loose
	and (wiki x) == ret in (ax (fpr wiki x ret)) being color colorAxEven to say thats true
	or being colorAxOdd to say it returns something other than ret but it does return/halt,
	else being color colorAxNonhalt to mean (wiki x) does not halt,
	the same as ax is used for funcs other than wiki,
	except wiki needs ax due to wiki being defined only by examples that fit together in NSAT puzzle,
	where the NSAT level is below the lambda level and may be computed in ways other than NSAT but thats the math spec.
	<br><br>
	You can effectively have unlimited number of wikis by using a linkedlist whose deepest part is the name of the wiki,
	and parts after that you use whatever you want, for example,
	and to fork one of those, use axioms (dovetailing derived in params of Op.ax, for example)
	to imply that if something exists in some parts of wiki then it exists (or translating it / migration / etc)
	in certain other parts, though convergence on a set of axioms is intentionally left nondeterministic
	so various groups of people and systems or combos of them or the whole world together,
	however they like to organize things, have not created a lambda contradiction (TruthValue.bull)
	by selecting from the space of all finite but otherwise turing complete ways to organize the wiki,
	where TruthValue.bull occurs when the same lambda call (func param) has more than 1 unique return value
	such as (wiki "hello")->"world" and (wiki "hello")->42 cant both exist,
	but (wiki ["testxyz435" "hello"])->"world" and (wiki ["monkeyspace" "hello"])->42 can exist together,
	or (wiki "testxyz435.hello") would also work, however you want to do it, just dont create lambda contradictions.
	Wiki is a pure math function and can call itself recursively, emulate itself, etc,
	such as (wiki "lazyCallWikiOnItself") -> {,wiki ,wiki} aka (s (t wiki) (t wiki))
	so if that exists (check Op.ax for any returnVal func param)
	then (wiki "lazyCallWikiOnItself" u) -> (wiki wiki),
	and there might be (wiki wiki)->"this is the return value of calling wiki on itself"
	so in that case (wiki "lazyCallWikiOnItself" u) -> "this is the return value of calling wiki on itself",
	or you could also use (s i i x) -> (x x) forall x, so (s i i wiki) -> (wiki wiki) -> whatever that returns.
	You could also make a function locally named testxyz435
	where (testxyz435 x) -> (wiki ["testxyz435" x]). Functions are useful for many possible things
	including convenient shortcuts or building virtual worlds so big and detailed
	you might mistake it for a remote interaction with the real world. You can put anything
	in the wiki as long as it doesnt create any lambda contradictions with the other contents
	and if you can get other people and computers to go along with it in them
	trying to not create lambda contradictions anywhere in the wiki considering its whole contents.
	The system will automatically look for such contradictions and automatically fork and merge
	in whatever ways people want it to as defined by functions they can create
	to help them understand other functions and create new useful functions.
	Everything can be automated and the automatic processes
	(built by people and AIs while using other automated processes)
	can choose between people andOr AIs at the time and context for whatever each does best,
	and if that doesnt work out, try other combos automatically.
	Everything gets connected to everything if thats what those parts want at the time and context.
	*/
	wiki(true,false,false,false,1),
	Wiki(false,true,false,false,1),
	
	
	/** FIXME (λ λ) is cleanLeaf and (λ (λ λ)) is dirtyLeaf, and l and r and isleaf and isclean ops must use it that way,
	such as (L (λ (λ λ))) is IdentityFunc) and (L (λ λ)) is identityFunc)
	and (R (λ (λ λ))) is (λ (λ λ)) and (R (λ λ)) is (λ λ), cuz forall x (L x (R x)) equals x,
	and this is to fix the problem of needing 2 leafs (cleanLeaf and dirtyLeaf) cuz clean cant derive dirty
	but if theres just 1 leaf (λ) then it could. 
	<br><br>
	a/isLeaf. TODO copy comments from wikibinator104 and maybe modify them...
	<br><br>
	(isLeaf x) is t or f depending if x is the leaf which all paths in the binary forest of call pairs lead to
	aka the wikibinator104 universal function itself.
	isLeaf, l, and r make this a "pattern calculus function".
	*/
	isLeaf(true,false,false,false,1), //todo rename to isleaf and Isleaf (the l is lowercase), to match isclean and Isclean
	IsLeaf(false,true,false,false,1),
	
	/** FIXME (λ λ) is cleanLeaf and (λ (λ λ)) is dirtyLeaf, and l and r and isleaf and isclean ops must use it that way,
	such as (L (λ (λ λ))) is IdentityFunc) and (L (λ λ)) is identityFunc)
	and (R (λ (λ λ))) is (λ (λ λ)) and (R (λ λ)) is (λ λ), cuz forall x (L x (R x)) equals x,
	and this is to fix the problem of needing 2 leafs (cleanLeaf and dirtyLeaf) cuz clean cant derive dirty
	but if theres just 1 leaf (λ) then it could.
	<br><br>
	l/getFunc. TODO copy comments from wikibinator104 and maybe modify them...
	<br><br>
	(l x) is left child of x in the binary forest of call pairs.
	Not the same as lispCar since pair is the church-pair lambda.
	isLeaf, l, and r make this a "pattern calculus function".
	*/
	getFunc(true,false,false,false,1),
	GetFunc(false,true,false,false,1),
	
	/** FIXME (λ λ) is cleanLeaf and (λ (λ λ)) is dirtyLeaf, and l and r and isleaf and isclean ops must use it that way,
	such as (L (λ (λ λ))) is IdentityFunc) and (L (λ λ)) is identityFunc)
	and (R (λ (λ λ))) is (λ (λ λ)) and (R (λ λ)) is (λ λ), cuz forall x (L x (R x)) equals x,
	and this is to fix the problem of needing 2 leafs (cleanLeaf and dirtyLeaf) cuz clean cant derive dirty
	but if theres just 1 leaf (λ) then it could. 
	<br><br>
	r/getParam. TODO copy comments from wikibinator104 and maybe modify them...
	<br><br>
	(r x) is right child of x in the binary forest of call pairs.
	Not the same as lispCdr since pair is the church-pair lambda.
	isLeaf, l, and r make this a "pattern calculus function".
	*/
	getParam(true,false,false,false,1),
	GetParam(false,true,false,false,1),
	
	//l/getFunc and r/getParam differ by only 1 opcode bit (being leaf vs anything_except_leaf*)
	
	/** λy.λz.y aka true. (pair b c tru) is b. Is the K lambda of https://en.wikipedia.org/wiki/SKI_combinator_calculus */
	tru(true,false,false,false,2),
	Tru(false,true,false,false,2),
	
	/** λy.λz.z aka false aka f. (fal λ) is identityFunc aka λz.z. (pair b c fal) is c. */
	fal(true,false,false,false,2),
	Fal(false,true,false,false,2),
	
	/** λx.λy.λz.zxy. Is the church-pair lambda and lispCons. */
	pair(true,false,false,false,3),
	Pair(false,true,false,false,3),
	
	/** λx.λy.λz.xz(yz) aka ((xz)(yz)). Is the S lambda of https://en.wikipedia.org/wiki/SKI_combinator_calculus */
	trecurse(true,false,false,false,3),
	Trecurse(false,true,false,false,3),

	
	/** (renamed Op.bit to Op.blob).
	Its a cbt if its clean and its (7th) param (of _root) is cleanLeaf or (cleanLeaf cleanLeaf).
	If its just Op.blob (is a 6 param call of _root) that is not a cbt.
	(blob cleanLeaf) is the bit 1.
	(blob (cleanLeaf cleanLeaf)) is the bit 0.
	(blob (cleanLeaf cleanLeaf) (blob (cleanLeaf cleanLeaf))) is 11.
	(blob (cleanLeaf cleanLeaf) (blob cleanLeaf)) is 10.
	(10 11) is 1011.
	(1011 (0 0 10)) is 10110010.
	In the marklar105b prototype of wikibinator105, it will efficiently support blobs up to 2^45-1 bits,
	and up to 2^80 blobs and other objects at any one time excluding those garbcoled (garbage collected),
	where a blob viewed as a bitstring is padded with 1 then 0s until the next powOf2,
	like 10110010 is the bitstring 101100, and 1 is the empty bitstring,
	and 10110011 is the bitstring 1011001.
	<br><br>
	If its param is λ, its 1, vs if its param is anything except λ, its 0,
	and either way it takes an infinite number of params (like infcur) aka is halted after each next curry,
	and at and after its first param (to choose 0 vs 1) its a cbt,
	and a cbt called on anything is a cbt twice as big and 1 higher,
	and if a cbt is called on a cbt of a different height it returns (itself itself) instead,
	else just creates a halted call pair of itself and the param.
	*/
	blob(true,false,false,true,1),
	Blob(false,true,false,true,1),
	
	
	isclean(true,false,false,false,1),
	/** the 2 leafs are (λ (λ λ)) dirtyLeaf and (λ λ) cleanleaf, which in L, R, Isleaf, and color appear as leafs
	and theres no way to get λ which is not a function but just a data structure optimization
	or vestigial design from when there was 1 leaf instead of 2
	TODO should there just be 2 symbols for it like λ and Λ?
	<br><br>
	isclean (vs Isclean) is useless since it always returns t since it is a clean func so truncates its param to clean before using it.
	Use Isclean instead. A clean func doesnt need to check for clean cuz its params are always clean after automatic truncation to clean.
	isclean always returns t (clean true). Isclean always returns T or F (dirty true or dirty false).
	<br><br>
	To convert a func to clean, just call i (clean identityFunc, aka (f λ)) on it, for automatic truncation.
	To convert a func to dirty, that would have to be derived, using L and R recursively to rebuild a func
	matching the param, starting from cleanLeaf instead of dirtyLeaf,
	which todo put an Evaler optimization in the VM to check for that specific Asdirty func
	and just flip the isclean bit recursively, so near as fast as if there was an op to do it,
	similar to hardware optimized double multiply math will be near as fast in an Evaler optimization
	despite it being seamlessly useable as lambdas all the way down to cleanLeaf
	(cbts/blobs should be clean for blob optimizations, else they run in interpreted mode very slowly).
	*/
	Isclean(false,true,false,false,1),
	
	
	
	/** UPDATE: use (infcur λ λ λ) instead of (t (t (t λ))) in the example below,
	cuz id types will often cache number of curries so far and remaining,
	such as marklarId105b can cache up to around 8 million number of params of 1 function
	so far and curries remaining, and past that would use interpreted mode and will (in theory)
	work in p2p network if a function takes 1 trillion parameters using ax fpr caching
	(cuz anything less than perfectly reproducing the behaviors of the universal function may be a security flaw),
	though you would normally use 1-20 parameters and put bigger things in linkedlists, blobs, treemaps, etc.
	<br><br>
	(curryOrInfcurOrTypeval λ) is infcur ((1) and (2)).
	(1) (curryOrInfcurOrTypeval λ type value) aka (infcur type value),
		where type != λ, is how to use it as typeval, though its still infcur as it can take infinity curries.
	(2) (curryOrInfcurOrTypeval λ λ ...) aka (infcur λ ...), is how to use it as not typeval.
	(3) (curryOrInfcurOrTypeval anythingExceptλ) is curry, and anythingExceptλ is a unarynum like (t (t (t λ))) aka ,,,λ.
	opByte can tell the difference between those 3 things since opByte knows λ vs anythingExceptλ for first 7 curries.
	Its important for that unarynum to be at curry 6 so every func's number of currys is known before
	opByte starts being copied from self.l().
	self.l().l().l()...l().opByte is always the same opByte at curry number 7 after leaf, if self is curry number 7 or higher.
	I didnt write these as 3 separate ops, cuz number of curries depends on its first param
	in a more detailed way than λ vs anythingExceptλ, cuz the anythingExceptλ is looked at in more detail
	to view it as a unarynum, therefore the first param of curryOrInfcurOrTypeval cant be used ONLY as an opbit
	to choose between these 3 op-like-things inside it.
	Using infcur as typeval vs anything_except_typeval could be an opbit, but since it comes after the unarynum
	(which is 0u aka λ to mean infinity curries, else is for example 3u aka (t (t (t λ))) to mean 3 curries
	(TODO start counting after funcbody or after the op or where?))... since it comes after the unarynum
	it cant be part of an op prefix (of n opbits), so these 3 things are joined into 1 op called curryOrInfcurOrTypeval,
	but in ImportStatic.java they will be 3 separate things,
	and ImportStatic.curry will be this curryOrInfcurOrTypeval and only acts as curry if you give it
	a unarynum thats at least 1u.
	*/
	curryOrInfcurOrTypeval(true,false,false,true,2),
	CurryOrInfcurOrTypeval(false,true,false,true,2),
	
	//cleancall will be derived at user level, not an op.
	

	
	/*UPDATE: getting rid of color (no, just changing which colors, and lambdas dont need them, but nsat level does)
	and instead will have 2 (or maybe 3) kinds of Op.ax:
	(No, dont do 3 kinds of ax at the lambda level,
	but the third kind would be for nonhalters at nsat level below the lambda level).
	The first param of ax is λ to choose axA, and is anything except λ to choose axB,
	each of these 2 params...
	<br><br>
	(axA x) and (axB x) cant both exist.
	(axA x) is halted if (x u)->u.
	(axB x) is halted if (x u) -> anything except u.
	//Maybe, (axC x) is halted if (x u) does not halt, but I'm unsure if should have an axC.
	(axA x y) -> (x (T y))
	(axB x y) -> (x (F y))
	How would that be detected? A lambda could generate a hash thats the same for (axA x) and (axB x),
	for any x, but different for axA vs axB, or something like that.
	(details to work out on whats a normed form)
	But what to do if theres BULL in it such as (axA (pair s pair)) and (axB (pair s pair)) exist
	somewhere reachable from the same node?
	..
	The 2 ax ops need more room. make room by getting rid of isColorDisproof and 1 other 1-param op.
	*/
	ax(true,false,false,true,3),
	Ax(false,true,false,true,3),
	
	/** (fpr func param ret λ) -> λ if (func param)->ret,
	and (fpr func param ret λ) -> (λ λ) if (func param) -> something other than ret (but it still returns),
	and (fpr func param ret λ) does not halt if (func param) does not halt.
	<br><br>
	By itself its a question, but with ax its a proof of the answer, the proof being in the color of (ax anything).
	Used with ax to store (func param)->ret cache or statements that it does not return that,
	or in VM theres normally a hashtable to store that more efficiently but could reflect it as that. 
	Normally used as (ax (fpr func param ret)) (which costs 4 callpairs to store),
	which is colorAxEven if (func param)->ret,
	and is colorAxOdd if (func param) -> something other than ret but does halt,
	and does not halt if (func param) does not halt
	(so colorAxNonhalt is only used at NSAT level, not at lambda level above it).
	Anything whose l() is not axType is colorNormal. Those are the 4 colors.
	axType can of course be used with other funcs as it only cares about
	does its param return something of even height, of odd height, or not return.
	<br><br>
	TODO what does (fpr x y z anything_except_λ) return?
	(ret λ)? (lazig x y)? {,x ,y}? (ax (fpr x y z))? (S I I (S I I))? z?
	*/
	fpr(true,false,false,false,4),
	Fpr(false,true,false,false,4);

	
	/** after (u u) aka clean or (u anything_except_u) aka dirty,
	this is "u" for leaf vs "∩" for anything except leaf, which is a binary prefix for each op.
	*
	public final String prefix;
	*
	public final int opbits;
	*/
	
	public final boolean isCertainlyClean;
	
	public final boolean isCertainlyDirty;
	
	public final boolean isAlwaysEvaling;
	
	public final boolean isVararg;
	
	/** is 0 if isStrange, cuz number of curries isnt a single number,
	may be vararg or may eval at 2 specific numbers of curries.
	*/
	public final int curriesElse0;
	
	
	public static Op atOpbyte(byte opbyte){
		return atOpbyte[opbyte&0xff];
	}
	
	/** unsigned */
	public static Op atOpbyte(int opbyte){
		return atOpbyte[opbyte];
	}
	
	/** unsigned */
	public static byte minUint8Of(Op o){
		return minUint8OfOp[o.ordinal()];
	}
	
	/** index is Op.ordinal().
	counterpart of atOpbyte, but is not unitary since thats a map of byte->Op where the same Op is multiple places.
	*/
	private static final byte[] minUint8OfOp;
	
	/** see comment of Op._chooser */
	private static final Op[] atOpbyte;
	static{
		atOpbyte = new Op[256];
		atOpbyte[0] = _deeplazy;
		atOpbyte[1] = _root; //chooser of chooser
		atOpbyte[2] = _chooser; //clean chooser, in this case cleanLeaf is at opbyte 2
		atOpbyte[3] = _Chooser; //dirty chooser, in this case dirtyLeaf is at opbyte 3.
		for(int opbyte=4; opbyte<128; opbyte++){ //some of these will be replaced
			atOpbyte[opbyte] = atOpbyte[opbyte>>1];
		}
		int opbyteAt7Curries = 128;
		for(int c=0; c<2; c++){
			boolean clean = c==0;
			for(Op op : Op.values()){
				if(op.isCertainlyClean==clean && op.curriesElse0!=0){
					for(int i=0; i<(1<<op.curriesElse0); i++){
						//lg("op "+toString((byte)opbyteAt7Curries)+" "+op);
						atOpbyte[opbyteAt7Curries++] = op;
					}
				}
			}
		}
		for(int opbyte=127; opbyte>=0; opbyte--){
			Op ifNextCurryIsLeaf = atOpbyte[opbyte*2]; //FIXME is this backward?
			Op ifNextCurryIsAnythingButLeaf = atOpbyte[opbyte*2+1]; //FIXME is this backward?
			if(ifNextCurryIsLeaf == ifNextCurryIsAnythingButLeaf){
				//If its the same Op regardless of next param
				atOpbyte[opbyte] = ifNextCurryIsLeaf;
			} //else leave it as _Chooser, _chooser, _root, or _deepLazy
		}
		minUint8OfOp = new byte[Op.values().length];
		for(int opbyte=255; opbyte>=0; opbyte--){
			minUint8OfOp[atOpbyte(opbyte).ordinal()] = (byte)opbyte;
		}
	}
	
	/** min uint8 opbyte of the Op. Most Ops have multiple opbytes.
	This is the one with the most params remaining (fewest params so far),
	like this is opbyte for trecurse instead of
	(treecurse u) or (trecurse anything_except_u) or (trecurse u u u),
	or for blob instead of (blob u) aka 1 or (blob (u u)) aka 0.
	*/
	public static byte opbyte(Op o){
		return minUint8OfOp[o.ordinal()];
	}
	
	/** If is already cleanLeaf/u or dirtyLeaf/U, stays as that.
	_root can go forward to either of those, but this wont go backward to it
	cuz the reflect ops (L R Isleaf Isclean) wrap around at leaf to "close the loop"
	to make (L x (R x)).equals(x) be true forall x,
	and that happens by (L u)==i and (L U)==I and (R u)==u and (R U)==U.
	If this is already _deeplazy or _root, stays as those.
	*/
	public static byte opbyteBefore(byte opbyte){
		//opbyte&0xff is unsigned and is 0 if _deeplazy, is 1 if _root, is 2 if cleanLeaf/u, is 3 if dirtyLeaf/U.
		return (opbyte&0xff)<4 ? opbyte : (byte)(opbyte>>1);
	}
	
	/** If already has 7 params, its the same opbyte, else shifts and puts a 1 */
	public static byte opbyteConcatCleanleaf(byte opbyte){
		return opbyte<0 ? opbyte : (byte)((opbyte<<1)|1); 
	}
	
	/** If already has 7 params, its the same opbyte, else shifts and puts a 0 */
	public static byte opbyteConcatAnythingButCleanleaf(byte opbyte){
		return opbyte<0 ? opbyte : (byte)(opbyte<<1);
	}
	
	//TODO rename isStrange to isVararg, counting ax as vararg since it evals at 2 specific number of curries,
	//which is a very weak form of vararg compared to the curry ops and 0 and 1 ops.
	
	
	private Op(boolean isCertainlyClean, boolean isCertainlyDirty,
			boolean isAlwaysEvaling, boolean isVararg, int curriesElse0){
		this.isCertainlyClean = isCertainlyClean;
		this.isCertainlyDirty = isCertainlyDirty;
		this.isAlwaysEvaling = isAlwaysEvaling;
		this.isVararg = isVararg;
		this.curriesElse0 = curriesElse0;
	}
	
	public static void lg(String line){
		System.out.println(line);
	}
	
	/** like 00110111 */
	static String toString(byte b) {
		return Integer.toBinaryString(256+(b&0xff)).substring(1);
	}
	
	//FIXME need to get rid of some ops so it fits.
	public static void main(String[] args){
		int sum = 0;
		lg("Ops...");
		for(Op op : Op.values()){
			if(Character.isLowerCase(op.name().charAt(0))){
				if(op.curriesElse0 != 0) sum += 1<<op.curriesElse0;
				int bits = sum;
				lg(toString((byte)bits)+" Op."+op+"("+op.curriesElse0+")");
			} //else skip the clean/dirty mirror, and just double the number in sum *= 2
		}
		lg("sumBeforeDoubling="+Integer.toBinaryString(sum));
		sum *= 2; //cuz first of 7 params chooses !isDirty (leaf) vs isDirty (anything except leaf)
		lg("sum="+Integer.toBinaryString(sum));
		if(sum > 1<<7) throw new RuntimeException(
			"Opcodes dont fit in 7 params. 0..7 curries each being leaf vs nonleaf fits in a byte,"
			+" as a bitstring size 0..7 then a high 1 bit, aka the byte opcode"
			+" used in an earlier version of SimpleFn.interpretedMode's switch statement.");
		
		lg("---ops sorted by opbyte---");
		for(int opbyte=0; opbyte<256; opbyte++){
			lg("op"+toString((byte)opbyte)+": "+atOpbyte(opbyte));
		}
		
		lg("---ops sorted by human readable name then by opbyte---");
		for(Op op : Op.values()){
			for(int opbyte=0; opbyte<256; opbyte++){
				if(atOpbyte[opbyte]==op){
					lg("op"+toString((byte)opbyte)+": "+atOpbyte(opbyte));
				}
			}
		}
	}

}
















