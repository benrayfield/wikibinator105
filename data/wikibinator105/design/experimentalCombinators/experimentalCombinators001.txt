Just do the CLEAN forms for now, as DIRTY mostly mirrors it.

These will be typed functions made of ax, which any 2 of them, one called on the other, returns another one of them in bigo1.

Might need opByte and maybe a few other bits, to be part of color?

Want to define the nsat (or preferably, just make it of nands) level, of the proof vs anything-except-proof colors, of these bigo1 ops. The bloomfilter (stored sparsely in these forests with a few bits of bloomfilter in each (where all contradictions occur within the bits inside a single node, as it cant be more than 1 color). Thats just one way to compute it, and GPU optimizations will fit seamlessly with that.
Callquads, which are used in occamsfuncer, do the debugStepOver etc (simulate the stack on the heap, statelessly), BUT callquads are less self referencing than wikibinator105 cuz a lambda cant see a nonhalted callquad cuz a callquad is a simulation of the stack state computing those lambdas. I want to fix that in some funcs I'll design using the existing wikibinator105 math especially Op.ax and Op.fpr.

u - leaf
ax - axiomOp, where (ax y)'s color is proof if (y u)->u, is color disproof if that returns something other than u, and is color wordsalad if that doesnt halt and therefore (ax y) doesnt halt. Colors other than wordsalad can be measured by lambdas as wordsalad is nonhalting. Color wordsalad will therefore never be generated by lambdas but can be seen at the nsat level in some cases (halting oracles are impossible, of course).
dsi - debugStepIntoOrOverIfAlreadyDeepest
dso - debugStepOver

(dso 